//Analysis

//Shortest path.
// This just needs to connect to our "Search" buttons. Our search buttons could store two variables, source_node and target_node

 ready: function(){
    window.cy = this;

    p = cy.elements().aStar({root: source_node, goal: target_node, directed: false}).path;
    return p

"""it returns three objects {
  found, /* true or false */
  distance, /* Distance of the shortest path, if found */
  path /* Ordered collection of elements in the shortest path, if found */
}
"""
// we could either filter out the graph on the page to only show those nodes, or have it open a second webpage, which may make more sense so it's not reloading the graph constantly on the main page\
//to filter
if (p) {
  p.filter(function(i,x) { return x != source_node && x != target_node; })
      .addClass('path_element');

  p.edgesWith(p)
      .addClass('path_element');
}

//If we just opened on the other page, we would just have to call p.path and display the info.

//creating a degree property for each node to apply to the cose-layout-styles.txt for sizing
//this should then be read in on the "mapData" for node size

var degmap = {};
var nodes = cy.nodes();
for(var i =0;i < nodes.length ; i++){
    degmap[nodes[i].id()] = {degree: nodes[i].degree()}     ;

    cy.batchData(degmap); creates this property for all nodes. If this doesn't work well, I can do it in Neo4j'

//core metrics for the "anlaysis" or "rankings" page
//want to look at betweenness centrality, degree, closeness centrality

//closeness.  Use normalized version
let ccn = cy.elements().closenessCentralityNormalized({directed:False});

cy.nodes().forEach( n => {
  n.data({
    ccn: ccn.closeness( n )
  });
} );
                             
//we can then query it similar to below to build the table
console.log( 'ccn of j: ' + ccn.closeness('#j') );
                             
                             
//betweenness centrality
let bc = cy.elements().betweennessCentrality({directed:False});

cy.nodes().forEach( n => {
  n.data({
    bc: bc.betweennessNormalized( n )
  });
} );

//similarly, we can then recall it for each node
console.log( 'bc of j: ' + bc.betweenness('#j') );


//degree centrality. Same idea
let dcn = cy.elements().degreeCentralityNormalized({directed:False});

cy.nodes().forEach( n => {
  n.data({
    dcn: dcn.degree( n )
  });
} );

console.log( 'dcn of j: ' + dcn.degree('#j') );

//page rank. same idea
let pr = cy.elements().pageRank();

cy.nodes().forEach( n => {
  n.data({
    pr: pr.rank( n )
  });
} );

console.log('g rank: ' + pr.rank('#g'));